# 책임 연쇄 패턴

- Chain Responsibility Pattern은 Handler chain에 따라 요청을 전달 할전달할 수 있는 디자인 패턴
- 요청을 수신한 각 핸들러는 요청을 처리하거나 다음 핸들러로 전달할지 결정된다.

## 구성
### Handler
- 클라이언트의 요청을 처리하기 위한 인터페이스를 정의
- 현재 핸들러에서 처리하지 않을것이라면 요청을 넘길 다음 핸들러를 구현 (처리할 수 없는 요청인 경우 마지막 핸들러까지 가서도 처리되지 않을 수 있습니다. 마지막 핸들러는 다음 핸들러를 갖지 않을 것이므로 이는 선택적으로 만드시면 됩니다.)

### Concrete Handler
- 요청을 처리합
- 다음 핸들러에 작업을 넘깁니다.

### Client
- Chain의 첫 번째 Concrete Handler 객체에 요청을 한다. (이를 요청하기 위해 클라이언트가 첫 번째 Concrete Handler에 접근할 수 있어야 합니다.)
- 클라이언트의 요청은 Chain에 존재하는 모든 핸들러로 전송될 수 있다.

## 장점
- 요청 처리 순서를 제어할 수 있다.
- 결합도를 감소해준다. 체인에 존재하는 객체들은 요청을 처리할 것인지 넘길 것인지만 판단하면 되고, 체인의 다른 객체들이 뭘 하는지 알 필요가 없다. 물론 이건 클라이언트도 몰라도 된다.
- Single Responsibility Principle(단일 책임 원칙)을 지킬 수 있다. 작업을 수행하는 클래스, 작업을 호출하는 클래스를 분리할 수 있다.
- Open, Closed Principle(개방/폐쇄 원칙)을 지킬 수 있다. 기존 클라이언트의 코드를 바꾸지 않고 새로운 핸들러를 앱에 추가할 수 있다.

## 단점
- 처리되지 않는 요청이 있을 수 있지만, 요청할 때는 이걸 알 수 없습니다. 체인의 끝까지 가야 알 수 있기 때문이죠.
- 체인을 잘 못 만들 경우 사이클이 발생할 수 있다.


# Reference
https://refactoring.guru/ko/design-patterns/chain-of-responsibility     
https://icksw.tistory.com/250  
